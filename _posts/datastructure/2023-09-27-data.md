---
title: "자료의 표현"
date: 2023-09-27
categories:
  - datastructure
tags:
  -
---


### 컴퓨터에서 자료 표현

숫자, 문자, 그림, 소리 등 모든 형식의 자료는 2진수 코드로 저장하고 처리된다.

<br>

**2진수 코드**

1, 0 또는 참, 거짓 조합이다. (전구를 생각하면 쉽다.)

<br>

단위는 아래와 같이 1비트, 니블, 바이트로 불린다. n개의 비트로 2^n 개의 숫자, 상태를 표현할 수 있다.

![binary-code](https://github.com/rha6780/rha6780.github.io/assets/47859845/2d0a33a0-03bd-4c72-b14c-d5f298809118)

<br>

## 숫자를 표현하는 방법

### **10진수 표현**

우리가 일상에서 사용하는 방식인 10진수를 어떻게 표현할 수 있을까? 현재 컴퓨터에서 사용하는 것은 2진수의 2의 보수 방식이지만, 참고용으로 정리해보자.

<br>

**존 형식 표현**

10진수 한자리를 표현할때 1바이트를 이용하고, 존 영역과 수치영역을 둔다. 존 영역은 항상 1111로 표현한다. (숫자 자리 사이의 구분선 역할)

<img width="829" alt="Screenshot_2023-09-27_at_1 25 09_AM" src="https://github.com/rha6780/rha6780.github.io/assets/47859845/8033648c-182a-40a2-b758-f1aa749fe3ba">

여러 자리일 때 마지막 자리의 존 영역에 부호를 표시한다. (1100 = 양수, 1101 = 음수)

<img width="822" alt="Screenshot_2023-09-27_at_1 29 26_AM" src="https://github.com/rha6780/rha6780.github.io/assets/47859845/080348df-a5bc-4d1a-b2c8-8fd83666796a">

    

<br>
<br>


**팩 형식 표현**

존 영역 없이 표현하고, 최하위 4비트에 부호를 표시한다. (1100 = 양수, 1101 = 음수)

<img width="816" alt="Screenshot_2023-09-27_at_1 31 49_AM" src="https://github.com/rha6780/rha6780.github.io/assets/47859845/15709e3a-b779-4d92-b783-4708d7cc803a">



<br>
<br>

**10진수 → 2진수로 표현**

10진수 숫자를 2진수로 표현한다. n개의 비트에 따라 2^n개의 숫자를 표현할 수 있다.

![Screenshot_2023-09-27_at_1 33 31_AM](https://github.com/rha6780/rha6780.github.io/assets/47859845/c3686300-d121-44f0-8d2b-1f5aec89a75b)

<br>
<br>

### **2진수 정수 표현**

**n비트 부호 절대값**

최상위 1비트를 부호 표시 (양수 = 0, 음수 = 1)

<img width="819" alt="Screenshot_2023-09-27_at_1 36 51_AM" src="https://github.com/rha6780/rha6780.github.io/assets/47859845/97ceb993-26b4-4644-adae-4371480ed654">


<br>
  

**1의 보수**

n개의 비트에서 음수를 표현할 때 n비트를 모두 1로 만든 비트에서 숫자를 빼는 방법

ex) 21을 음수로 표현한다고 할 때, 21의 2진수 00010101를 11111111과 빼면 -21로 표현된다.

<img width="158" alt="Screenshot_2023-09-27_at_1 44 51_AM" src="https://github.com/rha6780/rha6780.github.io/assets/47859845/b4b1e579-c603-42b9-b075-67275f3179b8">


<br>

**2의 보수 (현재 컴퓨터에서 사용하는 방식)**

1의 보수에서 +1을 하는 방식

<img width="183" alt="Screenshot_2023-09-27_at_1 47 28_AM" src="https://github.com/rha6780/rha6780.github.io/assets/47859845/c2293e95-c948-4ad9-87ff-a3e43a43d298">


<br>

표현 가능한 범위는 -(2^(n-1)) ~ (2^(n-1)-1)

<br>

**부호 절대값과 1의 보수의 문제점**

0을 표현하는 방식이 2가지가 되어서 논리적인 오류가 있고, 총 표현 가능한 범위는 -(2^(n-1)-1) ~ (2^(n-1)-1) 이다. 그렇기에 컴퓨터에서는 2의 보수를 사용한다. 3가지 방식의 공통점은 최상위 비트가 부호라는 점이다.


<br>
<br>

### 2진수의 실수 표현

**고정 소수점 표현**

소수점이 항상 최상위 비트의 왼쪽 밖에 고정되는 방식

ex) 00010101은 0.00010101 = 0.21 을 의미한다.

<br>

**부동 소수점 표현(현재 컴퓨터에서 사용하는 방식)**

지수부와 소수부를 나누어서 구성한다.

<img width="847" alt="Screenshot_2023-09-27_at_1 55 50_AM" src="https://github.com/rha6780/rha6780.github.io/assets/47859845/925a49c3-ad7a-4e5f-beb8-00c321ccc285">

<br>

## 문자를 표현하는 방법

**BCD 코드**

6비트를 이용해서 문자를 표현하는 방법으로, 상위 2비트를 존 비트로 하위 비트가 어떤 값인지 구분한다.

![Untitled](https://github.com/rha6780/rha6780.github.io/assets/47859845/28776602-eb29-4534-b491-0196632981fb)

<br>

**EBCDIC 코드**

8비트를 이용해서 문자를 표현하는 방법으로 상위 4비트를 존 비트로 둔다. 존비트의 조합으로 특수문자, 영어 대문자, 소문자 등을 구분할 수 있다.

<br>

**ASCII 코드**

7비트를 이용해서 문자를 표현하는 방법으로 상위 3비트를 존비트로 둔다.

<br>

**유니코드**

위 문자 표현들은 최대 8비트로 정의되지 않은 문자는 표현할 수 없다는 문제가 있다. 다양한 언어를 지원하기 위해 2바이트를 조합하여 하나의 글자를 표현하는 방식이다.

<br>
<br>

## 논리값 표현

논리값을 표현하기 위해서 다음과 같이 표현한다. 1바이트를 이용하여 논리 값(참, 거짓)을 표현하는데 3가지 방식이 있다.

1. 최하위 비트로만 표시 (참 = 00000001, 거짓 = 00000000)
2. 전체 비트로 표시 (참 = 11111111, 거짓 = 00000000)
3. 하나 이상의 비트가 1 (참 = 00000100, 거짓 = 00000000)

<br>
<br>
